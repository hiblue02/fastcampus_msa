## 트랜잭션과 ACID
### Atomicity(원자성)
    - 전체가 수행되나, 혹은 수행되지 않는 특성.
    - 어느 하나라도 실패하면, 이전에 수행된 변경사항들은 rollback 되어야 한다.
### Constitency(일관성)
    - 트랜잭션 실행 전과 실행 후에, 변경되는 데이터들은 일관성을 유지해야 한다. 
    - 도메인, 비즈니스에 따라 약속된 데이터의 변경들만 이루어져야 한다.
### Isolation(고립성)
    - 트랜잭션 간에는 서로 영향을 미치면 안된다.
### Durability(지속성)
    - 트랜잭션 완료 후 그 결과는 여구적으로 유지되어야 한다. 
## 분산 시스템 환경에서 트랜잭션을 유지하기 위한 방법
### n Phase Commit
#### 2 phase commit
    - Cordinator : 데이터 변경을 수해사는 서버(MSA 환경에서 각 서비스)들의 phase를 관리한다.
    - Participant : 트랜잭션 서비스
    - 2Phase : 1. prepare , 2. commit
        1. 트랜잭션이 시작되면, cordinator가 transaction ID를 샌성한다. 
        2. Cordinator는 각 서비스(participant)로 준비를 요청한다. 
        3. 모든 participant가 준비되었다(feat.Lock)고 응답한다. (실질적 데이터 변경은 일어나지 않은 상태)
        4. Cordinator는 Participant들에게 Commit을 요청한다. 
        5. Participant들은 이전에 준비했던 동작을 마저 진행하고, 실제 데이터 변경을 위한 commit을 진행한다. 
        6. 모든 participant에게 OK응답을 받게되면 트랜잭션이 완료된다. 
    - 2Phase의 한계    
        1. participant가 준비 상태에서 데이터에 Lock을 건다.
        2. Cordinator에 문제가 생기면, 모든 비즈니스가 정지된다. 
        3. Cordinator의 모든 결정은 취소할 수 없다. (commit/abort 결정 후 participant 처리 중 실패해도 돌이킬 수 없다.) 
### 보상 트랜잭션 
    - 정상적으로 commit된 api 호출에 대해서, commit 이전 상태로 되돌리기 위한 api
        1. 뱅킹 서비스로 계좌에 입금한다.
        2. 머니 서비스로 머니 잔액 수정으로 요청한다. > 실패한다.
        3. 뱅킹 서비스로 계좌 입금 거래 취소를 요청한다.
    - 보상 트랜잭션의 한계
        1. 보상 트랜잭션 요청에 지연 혹은 실패 문제가 생기는 경우, 보상 트랜잭션을 호출하는 주체는 명확한 판단이 어렵다. 
### Saga Pattern(2PC+보상 트랜잭션)   
