## 트랜잭션과 ACID
### Atomicity(원자성)
    - 전체가 수행되나, 혹은 수행되지 않는 특성.
    - 어느 하나라도 실패하면, 이전에 수행된 변경사항들은 rollback 되어야 한다.
### Constitency(일관성)
    - 트랜잭션 실행 전과 실행 후에, 변경되는 데이터들은 일관성을 유지해야 한다. 
    - 도메인, 비즈니스에 따라 약속된 데이터의 변경들만 이루어져야 한다.
### Isolation(고립성)
    - 트랜잭션 간에는 서로 영향을 미치면 안된다.
### Durability(지속성)
    - 트랜잭션 완료 후 그 결과는 여구적으로 유지되어야 한다. 
## 분산 시스템 환경에서 트랜잭션을 유지하기 위한 방법
### n Phase Commit
#### 2 phase commit
    - Cordinator : 데이터 변경을 수해사는 서버(MSA 환경에서 각 서비스)들의 phase를 관리한다.
    - Participant : 트랜잭션 서비스
    - 2Phase : 1. prepare , 2. commit
        1. 트랜잭션이 시작되면, cordinator가 transaction ID를 샌성한다. 
        2. Cordinator는 각 서비스(participant)로 준비를 요청한다. 
        3. 모든 participant가 준비되었다(feat.Lock)고 응답한다. (실질적 데이터 변경은 일어나지 않은 상태)
        4. Cordinator는 Participant들에게 Commit을 요청한다. 
        5. Participant들은 이전에 준비했던 동작을 마저 진행하고, 실제 데이터 변경을 위한 commit을 진행한다. 
        6. 모든 participant에게 OK응답을 받게되면 트랜잭션이 완료된다. 
    - 2Phase의 한계    
        1. participant가 준비 상태에서 데이터에 Lock을 건다.
        2. Cordinator에 문제가 생기면, 모든 비즈니스가 정지된다. 
        3. Cordinator의 모든 결정은 취소할 수 없다. (commit/abort 결정 후 participant 처리 중 실패해도 돌이킬 수 없다.) 
### 보상 트랜잭션 
    - 정상적으로 commit된 api 호출에 대해서, commit 이전 상태로 되돌리기 위한 api
        1. 뱅킹 서비스로 계좌에 입금한다.
        2. 머니 서비스로 머니 잔액 수정으로 요청한다. > 실패한다.
        3. 뱅킹 서비스로 계좌 입금 거래 취소를 요청한다.
    - 보상 트랜잭션의 한계
        1. 보상 트랜잭션 요청에 지연 혹은 실패 문제가 생기는 경우, 보상 트랜잭션을 호출하는 주체는 명확한 판단이 어렵다. 
### Saga Pattern(2PC+보상 트랜잭션)    
    - 아벤트 방식으로 트랜잭션에 포함된 여러 작업(각 서비스의 API Call)의 결과를 게시하고, 이벤트를 빋아 처리하여 다음 작업들을 진행.
        1. 송급 서비스가 송금 시작 이벤트를 게시한다. 
        2. 머니 서비스가 송금 시작 이벤트를 comsume 한다.
        3. 머니 서비스가 잔액이 충분한지 확인하고 결과 이벤트를 게시한다. 
        4. 뱅킹 서비스가 잔액 결과 이벤트를 consume 한다.
        5. 뱅킹 서비스가 펌뱅킹을 실행하고 결과를 게시한다. 
        6. 머니 서비스가 펌뱅킹 실행 결과를 구독한다. 
        7. 머니 서비스가 잔액을 변경하고 결과를 게시한다. 
        8. 송금 서비스가 잔액 변경 결과를 구독한다. 
    - 코레오그래피 Choreography 패턴
        - 독립적인 조율자를 두지 않고 Saga를 구현하는 방법. 구현이 간단하지만, 트랜잭션 상황을 모니터링 하기 어렵다.
        - 각 서비스에서는 정상 트랜잭션과 보상 트랜잭션을 경우에 따라 실행한다. 그러나 전체적인 서비스가 성공했는지는 각 서비스에서 알 수 없다. 
        - 이벤트를 발행하는 작업이 내부 서비스의 트랜잭션과 하나로 묶어야 한다. 
        - 각 서비스 입장에서는 구현이 단순하다. 복잡도가 낮다. 
    - 오케스트레이션 Orchestration 패턴
        - 독립적인 조율자를 두어, 하나의 Saga 트랜잭션에 대한 매니징을 담당하는 방법. 구현이 어렵지만, 전체적인 트랜잭션 모니터링이 수월하다.
        - 이벤트 결과를 받는 주체가 오케스트레이터다. (각 서비스가 오케스트레이터에게 이벤트 결과를 보낸다.)
        - 이벤트가 실패하면, 오케스트레이터가 보상 트랜잭션을 요청한다. 
        - 각 서비스의 구현이 간단해지고, 보상 트랜잭션만 구현하면 된다. 
        - 오케스트레이터에 비즈니스 로직이 포함되면 안 된다.
## 이벤트 소싱과 EDA(Event Driven Architecture)
### 이벤트 드리븐 방식
    - 이벤트를 기준으로, 모든 데이터의 변경을 처리. (마지막 데이터가 최종)
    - 데이터 변경 : 하나의 도메인을 특정할 수 있는 Key와 변경정보가 담긴 이벤트를 발행한다. 
    - 데이터 조회 : 하나의 도메인을 특정할 수 있는 Key를 조건으로 최종 Version 정보를 조회한다. 
    - 장애나 서버, 인프라에 문제가 발생해도, 앱이 복구되면 메세지 브로커에 의존해서 일관성(트랜잭)을 구현할 수 있다. 
    - 구성요소
        - Event Data : 이벤트 데이터 발생
        - Publisher : 이벤트 발행
        - EventData Store : 이벤트 저장소
        - Subscriber : 이벤트 구독
        - Subscriber & Publisher : 이벤트 구독 후 처리결과 발행
        - DataBase : 이벤트 구독 후 처리
    - 단점
        - 백업, 통제 정책을 수립해야 한다. (Event가 잘못 발행, 구독하면 데이터 정합성이 망가질 수 있다.)
### EDA 솔루션
    - Eventuate
        - Eventuate Local : event를 기반으로 하나의 서비스 Local 환경에서 Event Sourcing 플랫폼 구현을 도와주는 오픈소스
        - Eventuate Tram : 분산 데이터 환경을 도와주는 플랫폼 오픈소스, Saga, CQRS 패턴 구현을 도와주는 오픈 소스
    - Axon Framwork 
        - DDD, CQRS, EDA를 구현할 수 있게 해주는 오픈소스 프레임워크 
        - Axon Framework : Event Sourcing을 기반으로 한 데이터 관리 도구를 제공한다. CQRS, DDD를 구현할 수 있게 도와준다. Spring boot 의존성을 사용.
        - Axon Server : 조율자, 큐잉을 내재해 유량 조절, 이벤트를 저장.
    
        
